//
//  main.cpp
//  408_计算机网络
//
//  Created by NetEase on 16/9/8.
//  Copyright © 2016年 NetEase. All rights reserved.
//

#include <iostream>
int main(int argc, const char * argv[]) {
    
    return 0;
}

/*
 1.计算机网络体系结构：
   1）OSI：开放系统互联        2)TCP/IP协议体系结构(四层)
          (1)应用层            (1)应用层 支持万维网应用的HTTP协议,支持电子邮件的SMTP协议,支持文件传送的FTP协议
          (2)表示层            (2)运输层 TCP,UDP
          (3)会话层            (3)网际层 IP
          (4)运输层            (4)网络接口层
          (5)网路层
          (6)数据链路层
          (7)物理层
 
 2.网络层：
   1) 网络互连:多个网络通过路由器互连成为一个互连网络(互联网)。
   2）因特网的设计思路:
           (1)网络层向上只提供简单灵活的、无连接的、尽最大努力的交付。
           (2)网络在发送分组时不需要先建立连接。每一个分组独立发送。
           (3)由网络的主机中的｜运输层｜负责可靠通信。
 
   3）可靠通信由用户主机来保证｜不需要建立连接｜每个分组都有完整的终点地址。
 
 3.TCP/IP体系的网络层提供的是数据报服务。接下来讨论:网络层如何传送IP数据报。
   1)网际协议IP是用来使互连起来的许多计算机能够进行通信的。(网络层使用路由器)
   
   2)虚拟互连网络：即逻辑互连网络。互连起来的各种物理网络的异构性是客观存在的，但是利用IP协议可以使这些性能各异的网络
                 在网络层上看起来好像是一个统一的网络。
   ＝＝》当许多异构网络通过路由器互连起来时,如果所有的网络都是用相同的IP协议,那么在网络层讨论问题就很方便了。
  
   3)互联网中的源主机H1要把一个IP数据报发送给目的主机H2。主机H1先查看自己的路由表，看目的主机是否就在本网络。如是，就不要经过任何路由器而直接交付了。如果不是，就要路由转发了。
 
             IP数据报
   ＝＝》网络层1－－－网络层2－－－网络层3－－－网络层4－－－网络层5
 
 4.IP地址：全世界唯一的32位的标识符。
   1)分类的IP地址。IP地址：{<网络号>,<主机号>}
   2)子网的划分。划分子网只是把主机号这部分再进行划分。{<网络号>,<子网号>,<主机号>}
   3)构成超网。CIDR消除了传统的A,B,C类地址以及划分子网的概念。{<网络前缀>,<主机号>}
 
 5.IP地址和硬件地址：物理地址是数据链路层和物理层使用的地址。IP地址是网络层及以上各层使用的地址。
 
 6.地址解析协议ARP(Address Resolution Protocol)：
   1)已知一个机器的IP地址(32位)，需要找出其物理地址(48位)。
   2)网络层使用的是IP地址，但在实际网络的链路上传送数据帧时，最终还是使用该网络的硬件地址。
   3)在主机的ARP告诉缓存中存放一个从IP地址到硬件地址的映射表，并且这个映射表还经常动态更新。
 
   4)
    (1)当主机A要向|本局域网上|的某个主机B发送IP数据报时，就先在其ARP高速缓存中查看有无B的IP地址。如有，就在ARP高速缓存中查出B对应的硬件地址，写入MAC帧。然后把该MAC帧发网此硬件地址。
    (2)也可能查不到B的IP地址。可能是B刚入网，也可能是A的ARP高速缓存还是空的。
    (3)主机A自动运行ARP,发送一个广播，我的IP地址是XX,我的硬件地址是xx,我想知道IP地址为xx的硬件地址。如果某个主机发现自己的IP地址与广播中的IP地址相同，就把自己的硬件地址作为响应传送过去。其余的主机不予理睬。
    (4)主机A收到响应后，就在ARP高速缓存中写入主机B的IP地址到硬件地址的映射。
 
    (5)ARP解决的是同一个局域网上的主机或者路由器的IP地址到硬件地址的映射问题。
    (6)如果两个主机不在同一个局域网，那就要通过路由转发了。
 
 ＝＝》为什么不直接使用硬件地址进行通信, 而是使用抽象的IP地址并调用ARP来寻找相应的硬件地址呢？
      因为全世界各种各样的网络，它们使用不同的硬件地址。要使这些异构网络通信，就必须进行复杂的硬件地址转换了。
 
 7.IP层转发分组：(按主机所在的网络地址制作路由表)
   1)路由表:(目的网络地址,下一跳地址)
   2)//在IP数据报的首部没有说明“下一跳路由的IP地址”，那么待转发的数据报又怎样能找到下一跳的路由器呢？
     当路由器收到一个待转发的数据报，在从路由表得出下一跳的IP地址后，使用ARP转换成硬件地址，传送过去。

   3)分组转发算法(路由器收到某个待转发的数据报)：
     (1)从数据报的首部提取目的主机的IP地址D，得出网络地址N。
     (2)若N就是与此路由器直接相连的某个网络地址,则直接交付。
     (3)若路由表中有到达网络N的路由，则把数据交给路由表中指明的下一跳路由器。
     (4)转发分组出错。
 
 
 8.无分类编址CIDR(构造超网):IP地址后面加上"/",然后写上网络前缀所占的位数。
   已知IP地址：128.14.35.7/20 = (10000000|00001110|0010)0011|00000111
   前20位就是网络地址,这个地址所在的地址块中的最小地址和最大地址也能得到。不过主机号全0或者全1一般不使用。
 
 
 
 
 
 
 9.运输层：TCP/IP体系中运输层最重要的两种协议：UDP和TCP(面向连接的可靠服务，流量控制，拥塞控制)。
   1)UDP(User Datagram Protocol)用户数据报协议:
              (1)UDP是无连接的,发送数据之前不需要建立连接。
              (2)UDP提供尽最大努力交付，不保证可靠交付。
              (3)UDP是面向报文的。发送方的UDP对应用程序交下来的报文，在添加首部之后就下交给IP层。
              (4)UDP没有拥塞控制。
 
             UDP首部｜UDP的数据部分
     IP首部 ｜IP数据报的数据部分
     (1)源端口:
     (2)目的端口：
     (3)长度：
     (4)检验和：
 
   2)TCP(Transmission Control Protocol)传输控制协议:  {IP地址,端口号}
              (1)TCP是面向连接的，发送数据之前要建立TCP连接。
              (2)TCP提供可靠交付的服务。无差错，不丢失，不重复，按序到达。
              (3)TCP是面向字节流的。流：是指流入到进程或从进程流出的字节序列。
 
   3)连续ARQ(自动请求重传)协议和滑动窗口协议：
 
   4)在深入讨论TCP的可靠传输之前，必须先了解TCP报文段首部的格式：
     (1)TCP的全部功能都体现在它首部中各字段的作用。
        .源端口和目的端口，各占2个字节。
        .序号:TCP连接中传送的字节流中的每一个字节都按顺序编号。
        .确认号:期望收到对方传来的下一个字节的序号。如果确认号是N,那么序号N-1为止的所有数据都已经正确收到。
        .ACK确认:仅当ACK=1时，确认号字段才有效。
        .SYN同步：
        .FIN终止:
        .窗口:窗口字段明确指出了现在允许对方发送的数据量。
     
     (2)TCP可靠传输的实现：那就以 “以字节为单位的滑动窗口解释”
        .现在比如说有客户端A和服务器B，假定A发送数据,B给出确认。现在假定A收到了B发来的确认报文段，窗口是20,确认号是21.这表明B期望收到的下一个字节序号是31，前面30个字节已经正确接收了。那A就可以构造出自己的发送窗口。A的发送窗口里可以发送从31到50这20个字节，因为窗口是20.
        .现在假设A发送了字节序号31，32，33 的数据，但是B只收到了32,33，序号31没有收到(可能丢失了，可能滞留了)，但是B只能对按序收到的数据中的最高序号给出确认，因此确认报文中的确认号仍然是31，而不是32，或者33.
        .现在假设B收到了31，32，33，并且交付给主机了。那就发送确认号34，窗口还是20.
        .A收到确认号后，发送窗口往前滑动三个序号。
        .但是有可能B的确认滞留或者丢失了。为了保证可靠传输，A一段时间(计时器)后会重传这部分数据。直到得到B的确认。
 
 ＝＝＝》超时重传时间的选择：TCP放送方在规定的时间内没有收到确认，就要重传已发送的报文段。大于报文段的平均往返时间。
 
   5)TCP的流量控制:利用滑动窗口实现流量控制。
     (1)所谓流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收。
     (2)比如A向B发送数据，在建立连接时，B告诉A，我的接受窗口是400，那么发送方的发送窗口不能超过接收窗口的数值。
     (3)有一种死锁情况：B告诉A, 窗口是0，A也接收到了，就等B发送非零窗口的通知。一段时间后B发了个非0窗口，但是丢失了。这样A一直在等待B的非零窗口，
        而B在等A的数据。利用持续计时器，只要收到零窗口通知，就启动持续计时器。到了设置的事件，A发送一个零窗口探测报文段，B给出确认，若窗口值还是0，那就等着吧，如果不是0，僵局就打破了。
 
   6)TCP的拥塞控制:
     (1)若对网络中的某一资源((链路容量)带宽，交换节点中的缓存，处理机等)的需求超过了该资源能提供的可用部分，就会出现拥塞。
     (2)所谓拥塞控制就是防治过多的数据注入到网络中，使得网络中的路由器和链路不过载。
     (3)假设把节点的缓存容量扩大，那么到达该节点的分组均可在节点的缓存队列中，但是输出链路的容量和处理机的速度没有提高，那分组等待转发的时间就长了，那早就超时了，相当于滞留了。
 
     (4)几种拥塞控制的方法：
            .慢开始
            .拥塞避免
            .快重传
            .快恢复
        ＝＝》慢开始：主机刚开始发送数据的时候，如果立即把大量数据注入到网络，可能会引起网络拥塞。因为现在并不清楚当前的网络状况。
                    所以可以先试探一下，由小到大慢慢增大发送窗口。
        ＝＝》拥塞避免：让拥塞窗口值缓慢增大，每经过一个往返时间就把发送方的拥塞窗口值加1，而不是加倍。比慢开始算法的拥塞窗口增加缓慢的多。
                      无论是慢开始还是拥塞避免，只要发送发判断网络出现拥塞(没有按时收到确认)，拥塞窗口就会重新设置为1，并执行慢开始算法，迅速减少主机发送到网络的分组，使得发生拥塞的路由器有足够的时间把积压的分组处理完毕。
 
        ＝＝》快重传：发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段M3。
 
        ＝＝》快恢复：会把慢开始门限值减半，但是不执行慢开始算法，而是执行拥塞避免算法。在快重传之后，执行快恢复，而不是慢开始算法。
 
 
   7)TCP的运输连接管理：TCP是面向连接的协议，运输连接是用来传送TCP报文的。
     (1)运输连接：连接建立，数据传送，连接释放。
 
     (2)三次握手：
        .客户端A向服务器B发送连接请求报文段。同步位SYN＝1，序列号seq＝x;客户端A处于(同步已发送)状态。SYN_SENT。
        .服务器B收到客户端A的连接请求报文段后，若同意连接，就发出确认。SYN＝1，ACK＝1，ack＝x+1，序列号seq＝y；服务器B处于(同步收到)状态。SYN_RCVD。
        .客户端A收到服务器B的确认后，还要向服务器B发送确认。SYN=1,ACK=1,ack=y+1,seq=x+1。这时候TCP连接就建立了。
 
     ＝＝》为什么A还要再发一次确认呢？
            .比如说客户端A发送的请求连接报文段长时间滞留了，等它到达服务器B的时候，B以为客户端A又发送了连接请求。B又给予确认，但是A其实没有发连接请求，所以不理会这个确认，那这样服务器B的资源就浪费了。
            .如果采用三次握手机制的话，A没发确认，B就知道A并没有要求连接。
 
     ＝＝》如果客户端A的确认丢失了，这样B就以为A并没有要连接，所以不予理会A发来的数据，而A会重传这些数据，一定次数后还得不到确认，就断开连接了。
     ＝＝》如果服务器B给A的确认丢失了，A一定时间没收到确认会重新请求连接的。
 
     
 
     (3)四次挥手:
        .客户端A向其TCP发出连接释放报文段，并且停止发送数据。(终止)FIN=1,序列号seq＝u,它等于前面已经发送过的字节序号＋1.A进入终止等待1状态(FIN_WAIT_1)。
        .服务器B收到连接释放报文段后发出确认。ACK=1,ack=u+1,seq=v;服务器B就进入关闭等待状态(CLOSE_WAIT)。
         这时候TCP连接处于半关闭状态,客户端A已经没有数据要发送了，但是服务器B还是可以发送数据的。
 
        .客户端A收到服务器B的确认后，就进入终止等待2状态(FIN_WIAT_2)。等待B发出连接释放报文段。
 
        .若某一时刻服务器B也没有数据要发送了，B发出连接释放报文段，FIN=1,ACK=1,ack=u+1,seq=w;服务器B进入最后确认状态(LAST_ACK)。
 
        .客户端A收到服务器B的连接释放报文段后，发出确认。ACK=1,ack=w+1,seq=u+1;A进入时间等待状态(TIME_WAIT)。
         这时候TCP连接还没有释放。必须经过时间等待计时器设置的时间2MSL后，A才进入到closed状态。
 
      ＝＝》为什么A在TIME_WAIT状态必须等待2MSL时间呢？
           (1)保证A发送的最后一个确认能够到达B，如果A的确认丢失的话，处在最后确认状态的B会重传连接释放报文段。A就能收到这个重传的报文段。
              重新确认。不然A在发送完ACK后立即释放连接，B就有可能无法进入closed状态了。
           (2)A发送完最后一个ACK报文段后，再经过时间2MSL，可以使在网络中的报文段都消失。
 
 
 10.应用层
    1)每一个应用层协议都是为了解决某一类应用问题。应用层的具体内容就是 规定应用进程在通信时所遵循的协议。
    2)
 
 
*/